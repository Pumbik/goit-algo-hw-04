Порівняльний аналіз алгоритмів сортування

Метою мого домашнього завдання було емпірично перевірити теоретичні оцінки складності трьох алгоритмів сортування:
1. Insertion Sort   Сортування вставками
2. Merge Sort       Сортування злиттям
3. Timsort          Вбудований алгоритм Python

Тестування я проводив на масивах випадкових чисел розміром 100, 1000, 5000 та 10000 елементів.

Результати мого тестування:
Algorithm            | Size       | Time (sec)     
--------------------------------------------------
Insertion Sort       | 100        | 0.00070       
Merge Sort           | 100        | 0.00049       
Timsort (Built-in)   | 100        | 0.00003
--------------------------------------------------
Insertion Sort       | 1000       | 0.12780
Merge Sort           | 1000       | 0.01208
Timsort (Built-in)   | 1000       | 0.00035
--------------------------------------------------
Insertion Sort       | 5000       | 3.13118
Merge Sort           | 5000       | 0.06489
Timsort (Built-in)   | 5000       | 0.00303
--------------------------------------------------
Insertion Sort       | 10000      | 13.50256
Merge Sort           | 10000      | 0.13156
Timsort (Built-in)   | 10000      | 0.00533       
--------------------------------------------------

Аналіз результатів

1. Insertion Sort O(n^2)
	Результати чітко підтверджують квадратичну складність алгоритму.
	При збільшенні розміру масиву з 1,000 до 10,000 (у 10 разів), час виконання 
	збільшився з ~0.12 с до ~13.50 с, тобто приблизно в 100 разів (10^2).
	Це робить алгоритм неефективним для великих наборів даних.

2. Merge Sort O(n \log n)
	Цей алгоритм показав значно кращу ефективність. 
	Зростання часу виконання майже лінійне (з невеликим логарифмічним коефіцієнтом).
	Це підтверджує, що стратегія "розділяй і володарюй" є ефективною для сортування великих масивів.

3. Timsort (Гібридний алгоритм)
	А цей алгоритм показав найкращі результати на всіх наборах даних.
	На масиві з 10,000 елементів він виявився приблизно в 25 разів швидшим 
	за Merge Sort і в 2500 разів швидшим за Insertion Sort.


Висновки

Емпіричні дані підтвердили теоретичні оцінки складності алгоритмів.

Timsort оказався самим ефективним. Чому?
Наскільки мені відомо то алгоритм Timsort поєднує в собі переваги двох підходів:
1. Сортування вставками використовується для невеликих підмасивів (де воно працює дуже швидко через малі накладні витрати).
2. Сортування злиттям використовується для об'єднання цих відсортованих частин.

Алгоритм Timsort гарно оптимізован, і важливу роль відіграє те, що вбудована функція [sorted] реалізована на мові C, 
що дає значний приріст продуктивності порівняно з чистим Python-кодом.

Саме тому в реальних задачах краще використовувати вбудовані функції сортування Python, оскільки вони є максимально 
оптимізованими та адаптивними до даних.